<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3D Position Vector</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.85);
            color: #00ff00;
            padding: 10px;
            border-radius: 8px;
            pointer-events: none;
            border: 1px solid #00ff00;
            min-width: 240px;
            font-size: 14px;
        }

        h1 { margin-top: 0; font-size: 16px; color: #fff; text-decoration: underline;}
        .section { margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .data-row { display: flex; justify-content: space-between; margin-bottom: 2px; }
        .label { color: #aaa; }
        .value { font-weight: bold; color: #fff; }
        .highlight { color: #ffff00; }
        .instruction { margin-top: 15px; color: #00ffff; font-size: 12px; line-height: 1.5; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="hud">
        <h1>3D Position Vector</h1>
        
        <div class="section">
            <div class="data-row"><span class="label">Target (x,y,z):</span> <span class="value" id="targetPos">0,0,0</span></div>
            <div class="data-row"><span class="label">Arrow (x,y,z):</span> <span class="value" id="arrowPos">0,0,0</span></div>
        </div>

        <div class="section">
            <div class="data-row"><span class="label">ΔX:</span> <span class="value" id="dx">0</span></div>
            <div class="data-row"><span class="label">ΔY:</span> <span class="value" id="dy">0</span></div>
            <div class="data-row"><span class="label">ΔZ:</span> <span class="value" id="dz">0</span></div>
        </div>

        <div class="section">
            <div class="data-row"><span class="label">Horiz. Dist (xz):</span> <span class="value" id="hDist">0</span></div>
            <div class="data-row"><span class="label">Direct Dist (xyz):</span> <span class="value" id="tDist">0</span></div>
            <div class="data-row"><span class="label">Vert. Dist (zy):</span> <span class="value" id="vDist">0</span></div>
        </div>

        <div class="section">
            <div class="data-row"><span class="label">Yaw (Rotation Y):</span> <span class="value" id="rotY">0°</span></div>
            <div class="data-row"><span class="label">Pitch (Rotation X):</span> <span class="value" id="rotX">0°</span></div>
        </div>
        
        <div class="instruction">
            [WASD] Move Horizontally<br>
            [SPACE] Fly Up<br>
            [SHIFT] Fly Down
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);
        scene.add(new THREE.AmbientLight(0x404040));

        const grid = new THREE.GridHelper(50, 50, 0x444444, 0x222222);
        scene.add(grid);
        scene.add(new THREE.AxesHelper(5)); 

        const targetObj = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32),
            new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4 })
        );
        targetObj.position.set(0, 0, 0); 
        scene.add(targetObj);

        const arrowGeo = new THREE.ConeGeometry(0.5, 2, 16);
        arrowGeo.rotateX(Math.PI / 2); 
        
        const arrowObj = new THREE.Mesh(
            arrowGeo,
            new THREE.MeshStandardMaterial({ color: 0xffff00, metalness: 0.5, roughness: 0.2 })
        );
       
        arrowObj.rotation.order = 'YXZ'; 
        arrowObj.position.set(10, 5, 10);
        scene.add(arrowObj);

        const lineGeo = new THREE.BufferGeometry().setFromPoints([targetObj.position, arrowObj.position]);
        const lineObj = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.4 }));
        scene.add(lineObj);

        const shadowGeo = new THREE.BufferGeometry();
        const shadowLine = new THREE.Line(shadowGeo, new THREE.LineBasicMaterial({ color: 0x555555,  dashSize: 1, gapSize: 1 }));
        scene.add(shadowLine);

        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const ui = {
            tPos: document.getElementById('targetPos'),
            aPos: document.getElementById('arrowPos'),
            dx: document.getElementById('dx'),
            dy: document.getElementById('dy'),
            dz: document.getElementById('dz'),
            hDist: document.getElementById('hDist'),
            tDist: document.getElementById('tDist'),
            vDist: document.getElementById('vDist'),
            rotY: document.getElementById('rotY'),
            rotX: document.getElementById('rotX'),
        };

        function animate() {
            requestAnimationFrame(animate);

            const speed = 0.2;
            if (keys['KeyW'] || keys['ArrowUp']) arrowObj.position.z -= speed;
            if (keys['KeyS'] || keys['ArrowDown']) arrowObj.position.z += speed;
            if (keys['KeyA'] || keys['ArrowLeft']) arrowObj.position.x -= speed;
            if (keys['KeyD'] || keys['ArrowRight']) arrowObj.position.x += speed;
            if (keys['Space']) arrowObj.position.y += speed;
            if (keys['ShiftLeft'] || keys['ShiftRight']) arrowObj.position.y -= speed;

            const tx = targetObj.position.x;
            const ty = targetObj.position.y;
            const tz = targetObj.position.z;

            const ax = arrowObj.position.x;
            const ay = arrowObj.position.y;
            const az = arrowObj.position.z;

            const dx = tx - ax;
            const dy = ty - ay;
            const dz = tz - az;

            const horizDist = Math.sqrt(dx*dx + dz*dz);
            const totalDist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            const vertDist = Math.sqrt(dz*dz + dy*dy);

            const yaw = Math.atan2(dx, dz);

            const pitch = Math.atan2(dy, horizDist);

            arrowObj.rotation.y = yaw;
            arrowObj.rotation.x = -pitch; 
            
            lineObj.geometry.setFromPoints([targetObj.position, arrowObj.position]);
            

            shadowLine.geometry.setFromPoints([
                arrowObj.position, 
                new THREE.Vector3(ax, 0, az),
                new THREE.Vector3(tx, 0, tz)
            ]);

            const toDeg = (rad) => (rad * 180 / Math.PI).toFixed(1);

            ui.tPos.innerText = `${tx}, ${ty}, ${tz}`;
            ui.aPos.innerText = `${Math.abs(ax.toFixed(1))}, ${Math.abs(ay.toFixed(1))}, ${Math.abs(az.toFixed(1))}`;
            ui.dx.innerText = dx.toFixed(2);
            ui.dy.innerText = dy.toFixed(2);
            ui.dz.innerText = dz.toFixed(2);
            ui.hDist.innerText = horizDist.toFixed(2);
            ui.tDist.innerText = totalDist.toFixed(2);
            ui.vDist.innerText = vertDist.toFixed(2);
            
            ui.rotY.innerText = `${toDeg(yaw)}°`;
            ui.rotX.innerText = `${toDeg(pitch)}°`; 
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
